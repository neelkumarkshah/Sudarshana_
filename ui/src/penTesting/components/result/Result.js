import React, { useState, useEffect, useRef, useCallback } from "react";
import { Row, Col, Alert, Accordion, Spinner } from "react-bootstrap";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFilePdf, faShieldAlt } from "@fortawesome/free-solid-svg-icons";
import { Doughnut } from "react-chartjs-2";
import { Chart as ChartJS, Tooltip, Title, ArcElement, Legend } from "chart.js";

import PDFGeneration from "./PDF";
import CardBox from "../../../shared/components/uiElements/card/Card";
import ModalOverlay from "../../../shared/components/uiElements/modalOverlay/ModalOverlay";
import ButtonLayout from "../../../shared/components/uiElements/button/Button";
import classes from "./Result.module.css";
import { useAuth } from "../../../shared/hooks/auth-hook";

ChartJS.register(Tooltip, Title, ArcElement, Legend);

const cssOverride = `
    .accordion-button {
      border: 1px solid #dee2e6 !important;
      border-radius: 0.4rem !important;
      color: #1c3144 !important;
      font-weight: 600 !important;
    }

    .accordion-button:not(.collapsed) {
      color: #1c3144 !important;
      background-color: #ffffff !important;
      border: 1px solid #1c3144 !important;
      border-bottom-right-radius: 0 !important;
      border-bottom-left-radius: 0 !important;
      box-shadow: none !important;
    }

    p {
      color: #1c3144;
      text-align: justify;
    }

    a {
      color: #20a4f3;
    }

    a:hover, a:active, a:focus {
      color: #1c3144;
    }
  `;

const Result = ({ scanResult, onReset }) => {
  const severityStyles = {
    Critical: "#B80000",
    High: "#FF1F1F",
    Medium: "#EB701E",
    Low: "#FFDD33",
    Info: "#7AB851",
    Errors: "#860909",
  };
  const chartRef = useRef(null);

  const [renderedIssues, setRenderedIssues] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(-1);
  const [loading, setLoading] = useState(true);
  const [isPDFGenerated, setIsPDFGenerated] = useState(false);
  const [showOverlay, setShowOverlay] = useState(false);
  const [chartRendered, setChartRendered] = useState(false);
  const [pdfBlob, setPdfBlob] = useState(null);
  const [pdfName, setPdfName] = useState("");
  const [pdfError, setPdfError] = useState("");
  const [allIssuesRendered, setAllIssuesRendered] = useState(false);

  const [modalMessage, setModalMessage] = useState(
    "We are generating your PDF report, please wait..."
  );
  const [sevCounts, setSevCounts] = useState({
    Critical: 0,
    High: 0,
    Medium: 0,
    Low: 0,
    Info: 0,
    Errors: 0,
  });

  const totalIssues = scanResult?.scan?.issues?.length || 0;

  const { token } = useAuth();

  const uploadPDF = useCallback(
    async (pdfBlob) => {
      const formData = new FormData();
      formData.append("scanId", scanResult?.scan?.scanId);
      formData.append("pdfFile", pdfBlob);

      try {
        const response = await fetch(
          `${process.env.REACT_APP_BACKEND_URL}/pentesting/uploadPdf`,
          {
            headers: {
              authorization: `Bearer ${token}`,
            },
            method: "POST",
            body: formData,
          }
        );

        if (response.status !== 200) {
          throw new Error("Failed to upload PDF");
        }
      } catch (error) {}
    },
    [scanResult, token]
  );

  const resetScan = useCallback(() => {
    onReset();

    setRenderedIssues([]);
    setCurrentIndex(-1);
    setSevCounts({
      Critical: 0,
      High: 0,
      Medium: 0,
      Low: 0,
      Info: 0,
      Errors: 0,
    });
    setPdfBlob(null);
    setPdfName("");
    setLoading(true);
    setAllIssuesRendered(false);
  }, [onReset]);

  useEffect(() => {
    if (currentIndex >= 0 && currentIndex < totalIssues) {
      const issue = scanResult.scan.issues[currentIndex];

      setRenderedIssues((prevIssues) => [...prevIssues, issue]);

      setSevCounts((prevCounts) => {
        const newCounts = { ...prevCounts };
        if (newCounts[issue.Severity] !== undefined) {
          newCounts[issue.Severity]++;
        }
        return newCounts;
      });

      const delay = setTimeout(() => {
        setCurrentIndex((prevIndex) => prevIndex + 1);
      }, 2000);

      return () => clearTimeout(delay);
    } else if (currentIndex >= totalIssues) {
      setLoading(false);
      setChartRendered(true);
      setAllIssuesRendered(true);
    }
  }, [currentIndex, scanResult, totalIssues]);

  useEffect(() => {
    if (scanResult?.scan?.issues?.length > 0) {
      setCurrentIndex(0);
    }
  }, [scanResult]);

  const severities = {
    labels: ["Critical", "High", "Medium", "Low", "Info", "Errors"],
    datasets: [
      {
        data: [
          sevCounts.Critical,
          sevCounts.High,
          sevCounts.Medium,
          sevCounts.Low,
          sevCounts.Info,
          sevCounts.Errors,
        ],
        backgroundColor: [
          "#B80000",
          "#FF1F1F",
          "#EB701E",
          "#FFDD33",
          "#7AB851",
          "#860909",
        ],
        hoverBackgroundColor: [
          "#B80000",
          "#FF1F1F",
          "#EB701E",
          "#FFDD33",
          "#7AB851",
          "#860909",
        ],
        borderWidth: 0,
      },
    ],
  };

  const chartDesignOption = {
    responsive: true,
    maintainAspectRatio: true,
    plugins: {
      legend: {
        position: "top",
        labels: {
          font: {
            size: 14,
            family: "Times New Roman",
            weight: "bold",
          },
          color: "#1c3144",
          padding: 10,
        },
      },
    },
    layout: {
      padding: {
        bottom: 5,
      },
    },
  };

  useEffect(() => {
    if (!loading && chartRendered) {
      const generatePDF = async () => {
        try {
          const chartImage = chartRef.current.toBase64Image("image/png", 3);
          const applicationName = scanResult.scan.applicationName;

          // Generate PDF as blob
          const blob = await PDFGeneration(
            scanResult,
            chartImage,
            applicationName
          );

          // Save PDF blob locally for download later
          setPdfName(`${applicationName}_Security_Assessment_Report.pdf`);
          setPdfBlob(blob);
          await uploadPDF(blob);
        } catch (error) {
          setPdfError("Error generating PDF: " + error.message);
        }
      };

      generatePDF();
    }
  }, [scanResult, loading, chartRendered, uploadPDF]);

  const handleDownloadPDF = useCallback(() => {
    if (!isPDFGenerated) {
      setShowOverlay(true);
      setPdfError("");
      setModalMessage("We are generating your PDF report, please wait...");

      setTimeout(() => {
        setModalMessage("Your PDF is ready for download.");
        setIsPDFGenerated(true);

        setTimeout(() => {
          setShowOverlay(false);
          if (pdfBlob) {
            const url = URL.createObjectURL(pdfBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = pdfName;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
          }
        }, 3000);
      }, 5000);
    } else {
      if (pdfBlob) {
        const url = URL.createObjectURL(pdfBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = pdfName;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
      }
    }
  }, [isPDFGenerated, pdfBlob, pdfName]);

  return (
    <>
      <Row className={classes.reportRow}>
        <style>{cssOverride}</style>
        <Col sm={12} md={12} lg={8}>
          <CardBox className={classes.issueCard}>
            <h6 className={classes.scanReportTitle}>
              <strong>Scan Report</strong>
            </h6>

            {scanResult?.scan && (
              <div>
                {/* <pre>{JSON.stringify(scanResult, null, 2)}</pre> */}
                <Accordion alwaysOpen>
                  {renderedIssues.length > 0 ? (
                    renderedIssues.map((vulnerability, index) => (
                      <Accordion.Item
                        eventKey={index.toString()}
                        key={index}
                        className={`mb-3 ${classes.accordionItem}`}
                      >
                        <Accordion.Header className={classes.accordionHeader}>
                          {vulnerability.Vulnerability}
                        </Accordion.Header>
                        <Accordion.Body className={classes.accordionBody}>
                          <p>
                            <strong>Description: </strong>
                            {vulnerability.Description}
                          </p>
                          <p>
                            <strong>Severity: </strong>
                            <span
                              style={{
                                color: severityStyles[vulnerability.Severity],
                              }}
                            >
                              <strong>{vulnerability.Severity}</strong>
                            </span>
                          </p>
                          <p>
                            <strong>Proof of Concept: </strong>
                            <pre style={{ whiteSpace: "pre-wrap" }}>
                              {vulnerability.POC}
                            </pre>
                          </p>
                          <p>
                            <strong>Remediation: </strong>
                            {vulnerability.Remediation}
                          </p>
                          {vulnerability.Refer &&
                          Array.isArray(vulnerability.Refer) &&
                          vulnerability.Refer.length > 0 ? (
                            <>
                              <strong>Refer: </strong>
                              <ul>
                                {vulnerability.Refer.map(
                                  (reference, refIndex) => {
                                    const [url, ...titleParts] =
                                      reference.split(" - ");
                                    const title = titleParts.join(" - ");
                                    return (
                                      <li key={refIndex}>
                                        <a
                                          href={url}
                                          target="_blank"
                                          rel="noopener noreferrer"
                                        >
                                          {title || url}
                                        </a>
                                      </li>
                                    );
                                  }
                                )}
                              </ul>
                            </>
                          ) : (
                            <p>No references available.</p>
                          )}
                        </Accordion.Body>
                      </Accordion.Item>
                    ))
                  ) : (
                    <p className="text-center">No vulnerabilities found.</p>
                  )}
                </Accordion>
                {loading && (
                  <div className="text-center mt-3 mb-3">
                    <Spinner
                      animation="grow"
                      role="status"
                      className={classes.loadingSpinner}
                    />
                    <p className="text-center">Identifying the issues.....</p>
                  </div>
                )}
              </div>
            )}

            {scanResult?.error && (
              <Alert variant="danger" className="text-danger">
                {scanResult.error}
              </Alert>
            )}

            {pdfError && (
              <Alert variant="danger" className="text-danger">
                {pdfError}
              </Alert>
            )}
          </CardBox>
        </Col>

        <Col sm={12} md={12} lg={4}>
          <CardBox className={`${classes.issueCard} ${classes.sevCard}`}>
            <h6 className={classes.severityTitle}>
              <strong>Vulnerabilities by Severity</strong>
            </h6>
            <div className={classes.chartDesign}>
              <Doughnut
                ref={chartRef}
                data={severities}
                options={chartDesignOption}
              />
            </div>
            <hr className={classes.hr} />
            <div className={classes.generatePDF}>
              <ButtonLayout
                className={classes.pdfBtn}
                onClick={handleDownloadPDF}
                disabled={!chartRendered || !allIssuesRendered}
              >
                <FontAwesomeIcon icon={faFilePdf} className={classes.icon} />
                <span>Download PDF</span>
              </ButtonLayout>
            </div>
            <hr className={classes.hr} />
            <ButtonLayout
              type="submit"
              onClick={resetScan}
              className={classes.newScan}
            >
              <FontAwesomeIcon icon={faShieldAlt} className={classes.icon} />
              <span>Start New Scan</span>
            </ButtonLayout>
          </CardBox>
        </Col>
      </Row>
      <ModalOverlay
        show={showOverlay}
        onHide={() => setShowOverlay(false)}
        message={modalMessage}
      />
    </>
  );
};

export default Result;
