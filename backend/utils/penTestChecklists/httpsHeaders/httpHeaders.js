const fs = require("fs");
const path = require("path");
const axios = require("axios");

const logger = require("../../../configuration/logger");

const httpHeadersFile = path.join(__dirname, "httpHeaders.json");

const loadData = () => {
  try {
    const data = fs.readFileSync(httpHeadersFile, "utf8");
    const vulChecklistData = JSON.parse(data)["Missing HTTP Headers"];

    return vulChecklistData;
  } catch (err) {
    logger.error("Failed to load vulnerabilities data:", err);
    return [];
  }
};

const AnalyzeHeaders = async (headers, url) => {
  const vulChecklistData = loadData();
  const headerVulnerabilities = [];

  // Check and Validate Content-Security-Policy Header
  const CSP = async (cspData) => {
    try {
      const cspArray = cspData[0]["Content-Security-Policy"];
      const policies = cspArray[0]["Policies"];
      const issueData = cspArray[0]["Data"];

      const cspHeader = headers["content-security-policy"];

      logger.info("CSP scan started...");

      // Check Content-Security-Policy Header Exists
      if (!cspHeader) {
        const cspVul = {
          ...issueData[0],
          POC: headers,
        };
        if (cspVul) {
          headerVulnerabilities.push(cspVul);
        }
      } else {
        const hasRequiredPolicy = policies.some((policy) =>
          cspHeader.includes(policy)
        );
        if (!hasRequiredPolicy) {
          const cspPolicyVul = {
            ...issueData[1],
            POC: cspHeader,
          };
          if (cspPolicyVul) {
            headerVulnerabilities.push(cspPolicyVul);
          }
        }
      }

      logger.info("CSP scan ended...");
    } catch (error) {
      logger.error("Error in CSP analysis: ", error);
    }
  };

  // Check and Validate X-Content-Type-Options header
  const XCTO = async (xctoData) => {
    try {
      const xctoArray = xctoData[1]["X-Content-Type-Options"];
      const policies = xctoArray[0]["Policies"];
      const issueData = xctoArray[0]["Data"];

      const xctoHeader = headers["x-content-type-options"];
      const ctHeader = headers["content-type"];

      logger.info("CT/XCTO scan started...");

      const ctPolicy = policies[0];
      const hasctoPolicy = ctHeader && ctHeader.includes(ctPolicy);

      const xctoPolicy = policies[1];
      const hasxctoPolicy = xctoHeader && xctoHeader.includes(xctoPolicy);

      if (!hasctoPolicy) {
        const ctVul = {
          ...issueData[0],
          POC: headers,
        };
        if (ctVul) {
          headerVulnerabilities.push(ctVul);
        }
      }

      if (!hasxctoPolicy) {
        const xctoVul = {
          ...issueData[1],
          POC: headers,
        };
        if (xctoVul) {
          headerVulnerabilities.push(xctoVul);
        }
      }

      logger.info("CT/XCTO scan ended...");
    } catch (error) {
      logger.error("Error in CT/XCTO analysis: ", error);
    }
  };

  // Check and Validate X-Frame-Options header
  const XFO = async (xfoData) => {
    try {
      const xfoArray = xfoData[2]["X-Frame-Options"];
      const policies = xfoArray[0]["Policies"];
      const issueData = xfoArray[0]["Data"];

      const xfoHeader = headers["x-frame-options"];

      logger.info("XFO scan started...");

      if (
        !xfoHeader ||
        !policies.some((policy) => xfoHeader.includes(policy))
      ) {
        const xfoVul = {
          ...issueData[0],
          POC: headers,
        };
        if (xfoVul) {
          headerVulnerabilities.push(xfoVul);
        }
      }

      logger.info("XFO scan ended...");
    } catch (error) {
      logger.error("Error in XFO analysis: ", error);
    }
  };

  // Check for HTTP to HTTPS redirection and HSTS header
  const HttpsRedirection = async (url, issueData) => {
    try {
      logger.info("HttpsRedirection scan started...");

      const isHttp = url.startsWith("http://");

      if (isHttp) {
        const headResponse = await axios.head(url, {
          maxRedirects: 0,
          validateStatus: null,
        });

        if (
          headResponse.status >= 300 &&
          headResponse.status < 400 &&
          headResponse.headers.location
        ) {
          const finalUrl = headResponse.headers.location;

          if (finalUrl.startsWith("https://")) {
            const finalResponse = await axios.head(finalUrl, {
              maxRedirects: 0,
              validateStatus: null,
            });
            return finalResponse.headers["strict-transport-security"];
          } else {
            const httpsRedirectVul = {
              ...issueData[0],
              POC: headers,
            };
            logger.info("Missing HTTP to HTTPS redirection...");
            headerVulnerabilities.push(httpsRedirectVul);
          }
        } else {
          const httpsRedirectVul = {
            ...issueData[0],
            POC: headers,
          };
          logger.info("Missing HTTP to HTTPS redirection...");
          headerVulnerabilities.push(httpsRedirectVul);
        }
      }

      logger.info("HttpsRedirection scan ended...");
    } catch (error) {
      logger.error("Error in redirection analysis: ", error);
      return null;
    }
  };

  // Check and validate Strict-Transport-Security header
  const HSTS = async (hstsData, url) => {
    try {
      const hstsArray = hstsData[3]["HTTP Strict-Transport-Security"];
      const policies = hstsArray[0]["Policies"];
      const issueData = hstsArray[0]["Data"];

      logger.info("HSTS scan started...");

      if (url.startsWith("https://")) {
        // Fetch the HSTS header if the URL is HTTPS
        const hstsHeader = headers["strict-transport-security"];

        if (!hstsHeader) {
          const hstsVul = {
            ...issueData[1],
            POC: headers,
          };
          logger.info(
            "Missing HTTP Strict-Transport-Security (HSTS) Header..."
          );
          headerVulnerabilities.push(hstsVul);
          logger.info("HSTS scan ended...");
          return;
        }

        const maxAge = policies[0];
        const includeSubDomains = policies[1];
        const preload = policies[2];

        // Check if max-age is present
        const hasMaxAge = hstsHeader.includes(maxAge);

        // Check if includeSubDomains is present
        const hasIncludeSubDomains = hstsHeader.includes(includeSubDomains);

        // Check if preload is present
        const hasPreload = hstsHeader.includes(preload);

        // Check for missing max-age
        if (!hasMaxAge) {
          const hstsVul = {
            ...issueData[1],
            POC: hstsHeader,
          };
          if (hstsVul) {
            headerVulnerabilities.push(hstsVul);
          }
          return;
        }

        // Check for preload conditions
        if (hasPreload) {
          // Preload requires max-age >= 1 year and includeSubDomains
          if (hasMaxAge < 31536000 || !hasIncludeSubDomains) {
            const hstsVul = {
              ...issueData[1],
              POC: hstsHeader,
            };
            if (hstsVul) {
              headerVulnerabilities.push(hstsVul);
            }
          }
          return;
        }

        // Standard validation for max-age and includeSubDomains
        if (!hasIncludeSubDomains) {
          // Only max-age is present, no vulnerability to flag
          return;
        }

        // Both max-age and includeSubDomains are present
        return;
      } else {
        await HttpsRedirection(url, issueData);
      }

      logger.info("HSTS scan ended...");
    } catch (error) {
      logger.error("Error in HSTS analysis: ", error);
      return null;
    }
  };

  // Check and validate X-XSS-Protection header
  const XXSP = async (xxsData) => {
    try {
      const xxsArray = xxsData[4]["X-XSS-Protection"];
      const policies = xxsArray[0]["Policies"];
      const issueData = xxsArray[0]["Data"];

      const xssHeader = headers["x-xss-protection"];

      logger.info("XXSP scan started...");

      if (
        !xssHeader ||
        !policies.some((policy) => xssHeader.includes(policy))
      ) {
        const xssVul = {
          ...issueData[0],
          POC: headers,
        };
        if (xssVul) {
          headerVulnerabilities.push(xssVul);
        }
      }

      logger.info("XXSP scan ended...");
    } catch (error) {
      logger.error("Error in XXSP analysis: ", error);
    }
  };

  // Check and validate Referrer-Policy header
  const REFP = async (refpData) => {
    try {
      const refpArray = refpData[5]["Referrer-Policy"];
      const policies = refpArray[0]["Policies"];
      const issueData = refpArray[0]["Data"];

      const refpHeader = headers["referrer-policy"];

      logger.info("REFP scan started...");

      if (!refpHeader) {
        const refpVul = {
          ...issueData[0],
          POC: headers,
        };
        if (refpVul) {
          headerVulnerabilities.push(refpVul);
        }
      } else {
        if (!policies.some((policy) => refpHeader.includes(policy))) {
          const refpPolicyVul = {
            ...issueData[1],
            POC: refpHeader,
          };
          if (refpPolicyVul) {
            headerVulnerabilities.push(refpPolicyVul);
          }
        }
      }

      logger.info("REFP scan ended...");
    } catch (error) {
      logger.error("Error in REFP analysis: ", error);
    }
  };

  // Check and validate Permissions-Policy header
  const PPH = async (pphData) => {
    try {
      const pphArray = pphData[6]["Permissions-Policy"];
      const issueData = pphArray[0]["Data"];

      const pphHeader = headers["permissions-policy"];

      logger.info("PPH scan started...");

      if (!pphHeader) {
        const pphVul = {
          ...issueData[0],
          POC: headers,
        };
        if (pphVul) {
          headerVulnerabilities.push(pphVul);
        }
      }

      logger.info("PPH scan ended...");
    } catch (error) {
      logger.error("Error in PPH analysis: ", error);
    }
  };

  // Check and validate Cross-Origin-Resource-Sharing header
  const CORS = async (corsData) => {
    try {
      const corsArray = corsData[7]["Access-Control-Allow-Origin"];
      const policies = corsArray[0]["Policies"];
      const issueData = corsArray[0]["Data"];

      const corsHeader = headers["access-control-allow-origin"];
      const corsCredHeader = headers["access-control-allow-credentials"];
      const varyHeader = headers["vary"];
      const originHeader = headers["origin"];

      logger.info("CORS scan started...");

      if (!corsHeader) {
        const corsMissingVul = {
          ...issueData[0],
          POC: headers,
        };
        if (corsMissingVul) {
          headerVulnerabilities.push(corsMissingVul);
        }
        return;
      }

      const wildCardPolicy = policies[0];
      const hasWildcard = corsHeader && corsHeader.includes(wildCardPolicy);

      if (hasWildcard) {
        const wildcardVul = {
          ...issueData[1],
          POC: corsHeader,
        };
        if (wildcardVul) {
          headerVulnerabilities.push(wildcardVul);
        }

        if (corsCredHeader && corsCredHeader.toLowerCase() === "true") {
          const wildcardWithCredentialsVul = {
            ...issueData[2],
            POC: { corsHeader, corsCredHeader },
          };
          if (wildcardWithCredentialsVul) {
            headerVulnerabilities.push(wildcardWithCredentialsVul);
          }
        }
      }

      const nullPolicy = policies[1];
      const hasNull = corsHeader && corsHeader.includes(nullPolicy);

      if (hasNull) {
        const nullOriginVul = {
          ...issueData[3],
          POC: corsHeader,
        };
        if (nullOriginVul) {
          headerVulnerabilities.push(nullOriginVul);
        }
      }

      if (!hasWildcard && !hasNull && originHeader) {
        if (originHeader !== corsHeader) {
          const invalidOriginVul = {
            ...issueData[4],
            POC: { corsHeader, originHeader },
          };
          headerVulnerabilities.push(invalidOriginVul);
        }

        if (corsHeader && varyHeader) {
          const originPolicy = policies[2];
          const hasVaryOrigin = varyHeader
            .toLowerCase()
            .includes(originPolicy.toLowerCase());

          if (!hasVaryOrigin) {
            const varyOriginMissingVul = {
              ...issueData[5],
              POC: { corsHeader, varyHeader },
            };
            if (varyOriginMissingVul) {
              headerVulnerabilities.push(varyOriginMissingVul);
            }
          }
        }
      }

      logger.info("CORS scan ended...");
    } catch (error) {
      logger.error("Error in CORS analysis: ", error);
    }
  };

  // Check and validate Cross-Origin-Resource-Policy header
  const CORP = async (corpData) => {
    try {
      const corpArray = corpData[8]["Cross-Origin-Resource-Policy"];
      const policies = corpArray[0]["Policies"];
      const issueData = corpArray[0]["Data"];

      const corpHeader = headers["cross-origin-resource-policy"];
      const coepHeader = headers["cross-origin-embedder-policy"];

      logger.info("CORP scan started...");

      if (!corpHeader) {
        const corpMissingVul = {
          ...issueData[0],
          POC: headers,
        };
        if (corpMissingVul) {
          headerVulnerabilities.push(corpMissingVul);
        }
        return;
      }

      const crsoPolicy = policies[0];
      const hasCrsOrigin = corpHeader.includes(crsoPolicy);

      if (hasCrsOrigin) {
        const crsOriginVul = {
          ...issueData[1],
          POC: corpHeader,
        };
        if (crsOriginVul) {
          headerVulnerabilities.push(crsOriginVul);
        }
      }

      const ssPolicy = policies[1];
      const hasSS = corpHeader.includes(ssPolicy);

      const soPolicy = policies[2];
      const hasSOPolicy = corpHeader.includes(soPolicy);

      if (!hasSOPolicy && (hasSS || hasCrsOrigin)) {
        const ssCrsVul = {
          ...issueData[2],
          POC: corpHeader,
        };
        if (ssCrsVul) {
          headerVulnerabilities.push(ssCrsVul);
        }
      }

      if (coepHeader) {
        const conflictVul = {
          ...issueData[3],
          POC: coepHeader,
        };
        const coepPolicy = policies[3];

        const coepRequiresCORS = coepHeader.includes(coepPolicy);
        const conflictsWithCOEP = coepRequiresCORS && !hasCrsOrigin;

        if (conflictsWithCOEP) {
          headerVulnerabilities.push(conflictVul);
        }
      }

      logger.info("CORP scan ended...");
    } catch (error) {
      logger.error("Error in CORP analysis: ", error);
    }
  };

  // Check and validate Cross-Origin-Opener-Policy header
  const COOP = async (coopData) => {
    try {
      const coopArray = coopData[9]["Cross-Origin-Opener-Policy"];
      const policies = coopArray[0]["Policies"];
      const issueData = coopArray[0]["Data"];

      const coopHeader = headers["cross-origin-opener-policy"];
      const coepHeader = headers["cross-origin-embedder-policy"];

      logger.info("COOP scan started...");

      if (!coopHeader) {
        const coopMissingVul = {
          ...issueData[0],
          POC: headers,
        };
        if (coopMissingVul) {
          headerVulnerabilities.push(coopMissingVul);
        }
        return;
      }

      const unsafePolicy = policies[0];
      const hasUnsafeOrigin = coopHeader.includes(unsafePolicy);

      if (hasUnsafeOrigin) {
        const unsafeNoneVul = {
          ...issueData[1],
          POC: coopHeader,
        };
        if (unsafeNoneVul) {
          headerVulnerabilities.push(unsafeNoneVul);
        }
      }

      const soPolicy = policies[1];
      const hasSOPolicy = coopHeader.includes(soPolicy);

      const reqPolicy = policies[2];
      const hasReqPolicy = coepHeader && coepHeader.includes(reqPolicy);

      if (hasSOPolicy) {
        if (!coepHeader || !hasReqPolicy) {
          const conflictReqVul = {
            ...issueData[2],
            POC: { coopHeader, coepHeader },
          };
          if (conflictReqVul) {
            headerVulnerabilities.push(conflictReqVul);
          }
        }
      }

      logger.info("COOP scan ended...");
    } catch (error) {
      logger.error("Error in COOP analysis: ", error);
    }
  };

  // Check and validate Cross-Origin-Embedder-Policy header
  const COEP = async (coepData) => {
    try {
      const coepArray = coepData[10]["Cross-Origin-Embedder-Policy"];
      const policies = coepArray[0]["Policies"];
      const issueData = coepArray[0]["Data"];

      const coepHeader = headers["cross-origin-embedder-policy"];

      logger.info("COEP scan started...");

      if (!coepHeader) {
        const coepMissingVul = {
          ...issueData[0],
          POC: headers,
        };
        if (coepMissingVul) {
          headerVulnerabilities.push(coepMissingVul);
        }
        logger.info("COEP scan ended...");
        return;
      }

      const unsafePolicy = policies[0];
      const hasUnsafeOrigin = coepHeader.includes(unsafePolicy);

      if (hasUnsafeOrigin) {
        const unsafeNoneVul = {
          ...issueData[1],
          POC: coepHeader,
        };
        if (unsafeNoneVul) {
          headerVulnerabilities.push(unsafeNoneVul);
        }
      }

      const reCrPolicy = policies[1];
      const hasReCrPolicy = coepHeader.includes(reCrPolicy);

      if (!hasReCrPolicy && !hasUnsafeOrigin) {
        const reqCorpVul = {
          ...issueData[2],
          POC: coepHeader,
        };
        if (reqCorpVul) {
          headerVulnerabilities.push(reqCorpVul);
        }
      }

      logger.info("COEP scan ended...");
    } catch (error) {
      logger.error("Error in COEP analysis: ", error);
    }
  };

  // Check and validate Server header
  const ServerHeader = async (serverData) => {
    try {
      const serverArray = serverData[11]["Server"];
      const issueData = serverArray[0]["Data"];

      const serverHeader = headers["server"];

      if (!serverHeader) {
        return;
      }

      logger.info("ServerHeader scan started...");

      const serverPattern = /([a-zA-Z]+)\/([\d.]+)\s?\(([^)]+)\)?/;
      const matchesServerData = serverHeader.match(serverPattern);

      const ServerNameVersionPattern = /([a-zA-Z]+)\/([\d.]+)/;
      const matchesServerNameVersion = serverHeader.match(
        ServerNameVersionPattern
      );

      const serverPatternOne = /([a-zA-Z]+)/;
      const matchesServerName = serverHeader.match(serverPatternOne);

      if (matchesServerData) {
        const serverInfoDiscloseVul = {
          ...issueData[0],
          POC: serverHeader,
        };
        if (serverInfoDiscloseVul) {
          headerVulnerabilities.push(serverInfoDiscloseVul);
        }
      } else if (matchesServerNameVersion) {
        const serverNameVersionDiscloseVul = {
          ...issueData[1],
          POC: serverHeader,
        };
        if (serverNameVersionDiscloseVul) {
          headerVulnerabilities.push(serverNameVersionDiscloseVul);
        }
      } else if (matchesServerName) {
        const serverNameDiscloseVul = {
          ...issueData[2],
          POC: serverHeader,
        };
        if (serverNameDiscloseVul) {
          headerVulnerabilities.push(serverNameDiscloseVul);
        }
      }

      logger.info("ServerHeader scan ended...");
    } catch (error) {
      logger.error("Error in Server Header analysis: ", error);
    }
  };

  // Check and validate X-Powered-By header
  const XPB = async (xpbData) => {
    try {
      const xpbArray = xpbData[12]["X-Powered-By"];
      const issueData = xpbArray[0]["Data"];

      const xPoweredByHeader = headers["x-powered-by"];

      logger.info("XPB scan started...");

      if (xPoweredByHeader) {
        const xpbVul = {
          ...issueData[0],
          POC: xPoweredByHeader,
        };
        if (xpbVul) {
          headerVulnerabilities.push(xpbVul);
        }
      }

      logger.info("XPB scan ended...");
    } catch (error) {
      logger.error("Error in XPB analysis: ", error);
    }
  };

  // Check and validate X-AspNet-Version and X-AspNetMvc-Version header;
  const XASPNETVER = async (xaspnetverData) => {
    try {
      const xaspnetverArray = xaspnetverData[13]["X-AspNet-Version"];
      const issueData = xaspnetverArray[0]["Data"];

      const xAspnetVerHeader = headers["x-aspnet-version"];
      const xAspNetMvcVerHeader = headers["x-aspnetmvc-version"];

      logger.info("XASPNETVER scan started...");

      if (xAspnetVerHeader) {
        const xAspnetVerHeaderVul = {
          ...issueData[0],
          POC: xAspnetVerHeader,
        };
        if (xAspnetVerHeaderVul) {
          headerVulnerabilities.push(xAspnetVerHeaderVul);
        }
      }

      if (xAspNetMvcVerHeader) {
        const xAspNetMvcVerHeaderVul = {
          ...issueData[1],
          POC: xAspNetMvcVerHeader,
        };
        if (xAspNetMvcVerHeaderVul) {
          headerVulnerabilities.push(xAspNetMvcVerHeaderVul);
        }
      }

      logger.info("XASPNETVER scan ended...");
    } catch (error) {
      logger.error("Error in XASPNETVER analysis: ", error);
    }
  };

  // Check and validate X-DNS-Prefetch-Control header;
  const XDNSPC = async (xdnspfData) => {
    try {
      const xdnspfArray = xdnspfData[14]["X-DNS-Prefetch-Control"];
      const issueData = xdnspfArray[0]["Data"];

      const xdnspfHeader = headers["x-dns-prefetch-control"];

      logger.info("XDNSPC scan started...");

      if (xdnspfHeader && xdnspfHeader.toLowerCase() === "on") {
        const xdnspfHeaderVul = {
          ...issueData[0],
          POC: xdnspfHeader,
        };
        if (xdnspfHeaderVul) {
          headerVulnerabilities.push(xdnspfHeaderVul);
        }
      }

      logger.info("XDNSPC scan ended...");
    } catch (error) {
      logger.error("Error in XDNSPC analysis: ", error);
    }
  };

  // Check and validate Cookie header;
  const SC = async (scData) => {
    try {
      const scArray = scData[15]["Cookies"];
      const policies = scArray[0]["Policies"];
      const issueData = scArray[0]["Data"];

      let cookies = headers["set-cookie"];

      if (!cookies) {
        return;
      }

      if (Array.isArray(cookies)) {
        cookies = cookies.join("; ");
      }

      if (typeof cookies !== "string") {
        return;
      }

      const parsedCookies = cookies.split(";").map((cookie) => cookie.trim());

      logger.info("SC scan started...");

      const inSecureNamePolicy = policies[0];
      const inSecureHostNamePolicy = policies[1];

      const hasSecurePrefix = parsedCookies.some(
        (cookie) =>
          cookie.startsWith(inSecureNamePolicy) ||
          cookie.startsWith(inSecureHostNamePolicy)
      );

      if (!hasSecurePrefix) {
        const inSecureNameVul = {
          ...issueData[0],
          POC: cookies,
        };
        if (inSecureNameVul) {
          headerVulnerabilities.push(inSecureNameVul);
        }
      }

      const securePolicy = policies[2];
      const hasSecurePolicy = parsedCookies.some((cookie) =>
        cookie.toLowerCase().includes(securePolicy.toLowerCase())
      );

      if (!hasSecurePolicy) {
        const securePolicyVul = {
          ...issueData[1],
          POC: cookies,
        };
        if (securePolicyVul) {
          headerVulnerabilities.push(securePolicyVul);
        }
      }

      const httpOnlyPolicy = policies[3];
      const hasHttpOnlyPolicy = parsedCookies.some((cookie) =>
        cookie.toLowerCase().includes(httpOnlyPolicy.toLowerCase())
      );

      if (!hasHttpOnlyPolicy) {
        const httpOnlyPolicyVul = {
          ...issueData[2],
          POC: cookies,
        };
        if (httpOnlyPolicyVul) {
          headerVulnerabilities.push(httpOnlyPolicyVul);
        }
      }

      const ssLaxPolicy = policies[4];
      const ssStrictPolicy = policies[5];
      const hasSSPolicy = parsedCookies.some(
        (cookie) =>
          cookie.toLowerCase().includes(ssLaxPolicy.toLowerCase()) ||
          cookie.toLowerCase().includes(ssStrictPolicy.toLowerCase())
      );

      if (!hasSSPolicy) {
        const ssPolicyVul = {
          ...issueData[3],
          POC: cookies,
        };
        if (ssPolicyVul) {
          headerVulnerabilities.push(ssPolicyVul);
        }
      }

      const expiresCookiePolicy = policies[6];
      const maxAgeCookiePolicy = policies[7];

      const hasExpiresCookiePolicy = parsedCookies.some(
        (cookie) =>
          cookie.toLowerCase().includes(expiresCookiePolicy.toLowerCase()) ||
          cookie.toLowerCase().includes(maxAgeCookiePolicy.toLowerCase())
      );

      if (!hasExpiresCookiePolicy) {
        const expiresCookiePolicyVul = {
          ...issueData[4],
          POC: cookies,
        };
        if (expiresCookiePolicyVul) {
          headerVulnerabilities.push(expiresCookiePolicyVul);
        }
      } else {
        const expiresDate = new Date(hasExpiresCookiePolicy);
        if (expiresDate < new Date()) {
          const expiresCookiePolicyVul = {
            ...issueData[4],
            POC: cookies,
          };
          if (expiresCookiePolicyVul) {
            headerVulnerabilities.push(expiresCookiePolicyVul);
          }
        }
      }

      const domainPolicy = policies[8];
      const hasDomainPolicy = parsedCookies.some((cookie) =>
        cookie.toLowerCase().includes(domainPolicy.toLowerCase())
      );

      if (!hasDomainPolicy) {
        const domainPolicyVul = {
          ...issueData[5],
          POC: cookies,
        };
        if (domainPolicyVul) {
          headerVulnerabilities.push(domainPolicyVul);
        }
      }

      const pathPolicy = policies[9];
      const hasPathPolicy = parsedCookies.some((cookie) =>
        cookie.toLowerCase().includes(pathPolicy.toLowerCase())
      );

      if (!hasPathPolicy) {
        const pathPolicyVul = {
          ...issueData[6],
          POC: cookies,
        };
        if (pathPolicyVul) {
          headerVulnerabilities.push(pathPolicyVul);
        }
      }

      logger.info("SC scan ended...");
    } catch (error) {
      logger.error("Error in SC analysis: ", error);
    }
  };

  await CSP(vulChecklistData);
  await XCTO(vulChecklistData);
  await XFO(vulChecklistData);
  await HSTS(vulChecklistData, url);
  await XXSP(vulChecklistData);
  await REFP(vulChecklistData);
  await PPH(vulChecklistData);
  await CORS(vulChecklistData);
  await CORP(vulChecklistData);
  await COOP(vulChecklistData);
  await COEP(vulChecklistData);
  await ServerHeader(vulChecklistData);
  await XPB(vulChecklistData);
  await XASPNETVER(vulChecklistData);
  await XDNSPC(vulChecklistData);
  await SC(vulChecklistData);

  return headerVulnerabilities;
};

module.exports = {
  AnalyzeHeaders,
};
