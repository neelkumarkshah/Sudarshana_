import argparse
import json
import logging
import re
import time
import ssl
import socket
from ssl import CertificateError
from pathlib import Path
from typing import Dict, List, Union, Any
from datetime import datetime, UTC
import requests
from urllib.parse import urlparse
from tqdm import tqdm
from colorama import Fore, Style


# ===========================
# Logger Configuration
# ===========================
LOG_FILE = Path(__file__).parent / "Analysis.log"
logging.basicConfig(filename=LOG_FILE, level=logging.INFO,
                    format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("HeaderAnalyzer")


# ===========================
# Constants
# ===========================
VULNERABILITIES_FILE = Path(__file__).parent / "vulnerabilityList.json"


# ===========================
# Type Definitions
# ===========================
Headers = Dict[str, str]
Vulnerability = Dict[str, Union[str, Dict]]


WEAK_CIPHERS = ['RC4', '3DES', 'DES', 'NULL', 'SEED', 'IDEA', 'CAMELLIA']
INSECURE_PROTOCOLS = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']


# ===========================
# Helper Functions
# ===========================
def loadVulnerabilityData() -> List[Dict]:
    """
    Load vulnerability checklist data from a JSON file.
    :return: A list of vulnerabilities to check for.
    """
    try:
        with open(VULNERABILITIES_FILE, "r", encoding="utf-8") as file:
            data = json.load(file)
            return data.get("Missing HTTP Headers", [])
    except FileNotFoundError:
        logger.error(f"Vulnerability checklist file not found: {
                     VULNERABILITIES_FILE}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON file: {e}")
        return []


# ===========================
# URL Validation
# ===========================
def isValidUrl(url: str) -> bool:
    parsed_url = urlparse(url)
    return bool(parsed_url.scheme and parsed_url.netloc)


# ===========================
# Fetch Headers
# ===========================
def fetchHeaders(url: str) -> Headers:
    if not isValidUrl(url):
        logger.error(f"Invalid URL: {url}")
        return {}

    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return dict(response.headers)
    except requests.RequestException as e:
        logger.error(f"Request failed: {e}")
        return {}


# ===========================
# Header Analysis Functions
# ===========================
def analyzeCsp(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Content-Security-Policy header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        cspData = checklist[0]["Content-Security-Policy"]
        policies = cspData[0]["Policies"]
        issueData = cspData[0]["Data"]

        cspHeader = headers.get("Content-Security-Policy")

        logger.info("CSP scan started...")
        if not cspHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        elif not all(policy in cspHeader for policy in policies):
            vulnerabilities.append(
                {**issueData[1], "POC": cspHeader})
        logger.info("CSP scan completed.")
    except Exception as e:
        logger.error(f"Error during CSP analysis: {e}")


def analyzeXContentTypeOptions(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Content-Type-Options header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xctoData = checklist[1]["X-Content-Type-Options"]
        policies = xctoData[0]["Policies"]
        issueData = xctoData[0]["Data"]

        xctoHeader = headers.get("X-Content-Type-Options")
        ctHeader = headers.get("Content-Type")

        ctPolicy = policies[0]
        hasctoPolicy = ctHeader and ctPolicy in ctHeader

        xctoPolicy = policies[1]
        hasxctoPolicy = xctoHeader and xctoPolicy in xctoHeader

        logger.info("CT/XCTO scan started...")
        if not hasctoPolicy:
            vulnerabilities.append({**issueData[0], "POC": headers})

        if not hasxctoPolicy:
            vulnerabilities.append({**issueData[1], "POC": headers})
        logger.info("CT/XCTO scan completed.")
    except Exception as e:
        logger.error(f"Error during XCTO analysis: {e}")


def analyzeXFrameOptions(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Frame-Options header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xfoData = checklist[2]["X-Frame-Options"]
        policies = xfoData[0]["Policies"]
        issueData = xfoData[0]["Data"]

        xfoHeader = headers.get("X-Frame-Options")

        logger.info("XFO scan started...")
        if not xfoHeader or not any(policy in xfoHeader for policy in policies):
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XFO scan completed.")
    except Exception as e:
        logger.error(f"Error during XFO analysis: {e}")


def analyzeStrictTransportSecurity(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Strict-Transport-Security header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        hstsData = checklist[3]["HTTP Strict-Transport-Security"]
        policies = hstsData[0]["Policies"]
        issueData = hstsData[0]["Data"]

        logger.info("HSTS scan started...")

        if url.startswith("https://"):
            hstsHeader = headers.get("Strict-Transport-Security")
            if hstsHeader:
                maxAge = policies[0]
                includeSubDomains = policies[1]
                preload = policies[2]

                hasMaxAge = maxAge in hstsHeader
                hasIncludeSubdomains = includeSubDomains in hstsHeader
                hasPreload = preload in hstsHeader

                if not hasMaxAge:
                    vulnerabilities.append(
                        {**issueData[1], "POC": hstsHeader})
                    logger.info("Missing max-age in HSTS header.")
                    return

                if not hasIncludeSubdomains:
                    logger.info(
                        "Only max-age is present. No vulnerability flagged.")
                    return

                if hasPreload:
                    if hasMaxAge < 31536000 or not hasIncludeSubdomains:
                        vulnerabilities.append(
                            {**issueData[1], "POC": hstsHeader})
                        logger.info("Preload policy conditions not met.")
                        return

                # Valid configuration: max-age and includeSubDomains present (and optionally preload)
                logger.info("HSTS header is properly configured.")
                return
            else:
                vulnerabilities.append({**issueData[1], "POC": headers})
                logger.info(
                    "Missing HTTP Strict-Transport-Security (HSTS) header.")
        else:
            # Handle HTTP to HTTPS redirection
            logger.info("Checking HTTP to HTTPS redirection...")
            try:
                response = requests.head(url, allow_redirects=False)

                if 300 <= response.status_code < 400 and "location" in response.headers:
                    redirectUrl = response.headers["location"]
                    if redirectUrl.startswith("https://"):
                        # Follow redirected request to get final headers
                        finalResponse = requests.head(
                            redirectUrl, allow_redirects=False)
                        finalHsts = finalResponse.headers.get(
                            "Strict-Transport-Security")
                        if not finalHsts:
                            vulnerabilities.append(
                                {**issueData[0], "POC": finalResponse.headers})
                            logger.info(
                                "Missing HSTS header on HTTPS redirect target.")
                    else:
                        vulnerabilities.append(
                            {**issueData[0], "POC": response.headers})
                        logger.info("Redirect does not lead to HTTPS.")
                else:
                    vulnerabilities.append(
                        {**issueData[0], "POC": response.headers})
                    logger.info("No redirection from HTTP to HTTPS.")
            except Exception as redirectError:
                logger.error(
                    f"Error during redirection analysis: {redirectError}")
        logger.info("HSTS scan completed.")
    except Exception as e:
        logger.error(f"Error during HSTS analysis: {e}")


def analyzeXXSSProtection(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-XSS-Protection header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xxssData = checklist[4]["X-XSS-Protection"]
        policies = xxssData[0]["Policies"]
        issueData = xxssData[0]["Data"]

        xxssHeader = headers.get("X-XSS-Protection")

        logger.info("XXSS scan started...")
        if not xxssHeader or policies[0] not in xxssHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XXSS scan completed.")
    except Exception as e:
        logger.error(f"Error during XXSS analysis: {e}")


def analyzeReferrerPolicy(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Referrer-Policy header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        refpData = checklist[5]["Referrer-Policy"]
        policies = refpData[0]["Policies"]
        issueData = refpData[0]["Data"]

        refpHeader = headers.get("Referrer-Policy")

        logger.info("Referrer-Policy scan started...")

        if not refpHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        elif not any(policy in refpHeader for policy in policies):
            vulnerabilities.append(
                {**issueData[1], "POC": refpHeader})

        logger.info("Referrer-Policy scan completed.")
    except Exception as e:
        logger.error(f"Error during Referrer-Policy analysis: {e}")


def analyzePermissionsPolicy(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Permissions-Policy header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        pphData = checklist[6]["Permissions-Policy"]
        issueData = pphData[0]["Data"]

        pphHeader = headers.get("Permissions-Policy")

        logger.info("Permissions-Policy scan started...")

        if not pphHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})

        logger.info("Permissions-Policy scan completed.")
    except Exception as e:
        logger.error(f"Error during Permissions-Policy analysis: {e}")


def analyzeCORS(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Resource-Sharing (CORS) headers.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        corsData = checklist[7]["Access-Control-Allow-Origin"]
        policies = corsData[0]["Policies"]
        issueData = corsData[0]["Data"]

        corsHeader = headers.get("Access-Control-Allow-Origin")
        corsCredHeader = headers.get("Access-Control-Allow-Credentials")
        varyHeader = headers.get("Vary")
        originHeader = headers.get("Origin")

        logger.info("CORS scan started...")

        if not corsHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        wildCardPolicy = policies[0]
        hasWildcard = wildCardPolicy in corsHeader

        if hasWildcard:
            vulnerabilities.append(
                {**issueData[1], "POC": corsHeader})
            if corsCredHeader:
                vulnerabilities.append(
                    {**issueData[2], "POC": {corsHeader, corsCredHeader}})

        nullPolicy = policies[1]
        hasNull = nullPolicy in corsHeader

        if hasNull:
            vulnerabilities.append(
                {**issueData[3], "POC": corsHeader})

        if originHeader != corsHeader and not hasWildcard and not hasNull:
            vulnerabilities.append(
                {**issueData[4], "POC": {corsHeader, originHeader}})

        originPolicy = policies[2]
        hasVaryOrigin = originPolicy in varyHeader
        if varyHeader and not hasVaryOrigin:
            vulnerabilities.append(
                {**issueData[5], "POC": {corsHeader, varyHeader}})

        logger.info("CORS scan completed.")
    except Exception as e:
        logger.error(f"Error during CORS analysis: {e}")


def analyzeCORP(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Resource-Policy (CORP) header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        corpData = checklist[8]["Cross-Origin-Resource-Policy"]
        policies = corpData[0]["Policies"]
        issueData = corpData[0]["Data"]

        corpHeader = headers.get("Cross-Origin-Resource-Policy")
        coepHeader = headers.get("Cross-Origin-Embedder-Policy")

        logger.info("CORP scan started...")

        if not corpHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        crsoPolicy = policies[0]
        hasCrsOrigin = crsoPolicy in corpHeader

        if hasCrsOrigin:
            vulnerabilities.append(
                {**issueData[1], "POC": corpHeader})

        ssPolicy = policies[1]
        hasSS = ssPolicy in corpHeader

        soPolicy = policies[2]
        hasSOPolicy = soPolicy in corpHeader

        if (not hasSOPolicy and (hasSS or hasCrsOrigin)):
            vulnerabilities.append(
                {**issueData[2], "POC": corpHeader})

        coepPolicy = policies[3]
        if coepHeader and coepPolicy in coepHeader and crsoPolicy not in corpHeader:
            vulnerabilities.append({**issueData[3], "POC": coepHeader})

        logger.info("CORP scan completed.")
    except Exception as e:
        logger.error(f"Error during CORP analysis: {e}")


def analyzeCOOP(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Opener-Policy (COOP) header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        coopData = checklist[9]["Cross-Origin-Opener-Policy"]
        policies = coopData[0]["Policies"]
        issueData = coopData[0]["Data"]

        coopHeader = headers.get("Cross-Origin-Opener-Policy")
        coepHeader = headers.get("Cross-Origin-Embedder-Policy")

        logger.info("COOP scan started...")

        if not coopHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        unsafePolicy = policies[0]
        if unsafePolicy in coopHeader:
            vulnerabilities.append(
                {**issueData[1], "POC": coopHeader})

        soPolicy = policies[1]

        hasSOPolicy = coopHeader and soPolicy in coopHeader

        reqPolicy = policies[2]
        hasReqPolicy = coopHeader and reqPolicy in coopHeader

        if coopHeader and hasSOPolicy:
            if not coepHeader or not hasReqPolicy:
                vulnerabilities.append({
                    **issueData[2],
                    "POC": {
                        coopHeader,
                        coepHeader
                    }
                })

        logger.info("COOP scan completed.")
    except Exception as e:
        logger.error(f"Error during COOP analysis: {e}")


def analyzeCoep(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Embedder-Policy header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        coepData = checklist[10]["Cross-Origin-Embedder-Policy"]
        policies = coepData[0]["Policies"]
        issueData = coepData[0]["Data"]

        coepHeader = headers.get("Cross-Origin-Embedder-Policy")

        unsafePolicy = policies[0]
        reCrPolicy = policies[1]

        logger.info("COEP scan started...")
        if not coepHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        else:
            if any(policy in coepHeader for policy in policies):
                for i, policy in enumerate(policies):
                    if policy == unsafePolicy:  # Unsafe origin policy
                        vulnerabilities.append(
                            {**issueData[1], "POC": coepHeader})
                    if policy == reCrPolicy:  # Required CORP policy missing
                        vulnerabilities.append(
                            {**issueData[2], "POC": coepHeader})
        logger.info("COEP scan completed.")
    except Exception as e:
        logger.error(f"Error during COEP analysis: {e}")


def analyzeServerHeader(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Server header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        serverData = checklist[11]["Server"]
        issueData = serverData[0]["Data"]

        serverHeader = headers.get("Server")

        logger.info("ServerHeader scan started...")
        if serverHeader:
            serverPattern = r"([a-zA-Z]+)\/([\d.]+)\s?\(([^)]+)\)?"
            matchesServerData = re.match(serverPattern, serverHeader)
            serverNameVersionPattern = r"([a-zA-Z]+)\/([\d.]+)"
            matchesServerNameVersion = re.match(
                serverNameVersionPattern, serverHeader)

            if matchesServerData:
                vulnerabilities.append({**issueData[0], "POC": serverHeader})
            elif matchesServerNameVersion:
                vulnerabilities.append({**issueData[1], "POC": serverHeader})
            else:
                vulnerabilities.append({**issueData[2], "POC": serverHeader})
        logger.info("ServerHeader scan completed.")
    except Exception as e:
        logger.error(f"Error during Server Header analysis: {e}")


def analyzeXPoweredBy(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Powered-By header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xpbData = checklist[12]["X-Powered-By"]
        issueData = xpbData[0]["Data"]

        xPoweredByHeader = headers.get("X-Powered-By")

        logger.info("XPB scan started...")
        if xPoweredByHeader:
            vulnerabilities.append({**issueData[0], "POC": xPoweredByHeader})
        logger.info("XPB scan completed.")
    except Exception as e:
        logger.error(f"Error during XPB analysis: {e}")


def analyzeXAspNetVersion(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-AspNet-Version and X-AspNetMvc-Version headers.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xaspnetverData = checklist[13]["X-AspNet-Version"]
        issueData = xaspnetverData[0]["Data"]

        xAspnetVerHeader = headers.get("X-AspNet-Version")
        xAspNetMvcVerHeader = headers.get("X-AspNetMvc-Version")

        logger.info("XASPNETVER scan started...")
        if xAspnetVerHeader:
            vulnerabilities.append({**issueData[0], "POC": xAspnetVerHeader})
        if xAspNetMvcVerHeader:
            vulnerabilities.append(
                {**issueData[1], "POC": xAspNetMvcVerHeader})
        logger.info("XASPNETVER scan completed.")
    except Exception as e:
        logger.error(f"Error during XASPNETVER analysis: {e}")


def analyzeXDnsPrefetchControl(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-DNS-Prefetch-Control header.

    :param headers: The HTTP headers to analyze.
    :param url: Target URL to extract hostname.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xdnspfData = checklist[14]["X-DNS-Prefetch-Control"]
        issueData = xdnspfData[0]["Data"]

        xdnspfHeader = headers.get("X-DNS-Prefetch-Control")

        logger.info("XDNSPC scan started...")
        if xdnspfHeader:
            vulnerabilities.append({**issueData[0], "POC": xdnspfHeader})
        logger.info("XDNSPC scan completed.")
    except Exception as e:
        logger.error(f"Error during XDNSPC analysis: {e}")


def analyzeCookies(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cookies from HTTP headers for policy violations.

    :param headers: Dictionary of HTTP headers.
    :param url: Target URL to extract hostname.
    :param checklist: Security policy definitions and issue metadata.
    :param vulnerabilities: Collection list to append discovered issues.
    """
    try:
        scData = checklist[15]["Cookies"]
        policies = scData[0]["Policies"]
        issueData = scData[0]["Data"]

        cookies = headers.get("Set-Cookie")
        if not cookies:
            return

        if isinstance(cookies, list):
            cookies = "; ".join(cookies)
        elif isinstance(cookies, str):
            cookies = cookies
        else:
            return

        parsedCookies = [cookie.strip() for cookie in cookies.split(";")]

        logger.info("SC scan started...")

        # Insecure name policies
        inSecureNamePolicy = policies[0]
        inSecureHostNamePolicy = policies[1]
        hasInsecureNamePolicy = any(
            cookie.startswith(hasInsecureNamePolicy) or cookie.startswith(
                inSecureHostNamePolicy)
            for cookie in parsedCookies
        )

        if not hasInsecureNamePolicy:
            vulnerabilities.append({**issueData[0], "POC": cookies})

        # Secure flag
        securePolicy = policies[2]
        if not any(securePolicy in cookie for cookie in parsedCookies):
            vulnerabilities.append({**issueData[1], "POC": cookies})

        # HttpOnly flag
        httpOnlyPolicy = policies[3]
        if not any(httpOnlyPolicy in cookie for cookie in parsedCookies):
            vulnerabilities.append({**issueData[2], "POC": cookies})

        # SameSite
        ssLaxPolicy = policies[4]
        ssStrictPolicy = policies[5]
        if not any(ssLaxPolicy in cookie or ssStrictPolicy in cookie for cookie in parsedCookies):
            vulnerabilities.append({**issueData[3], "POC": cookies})

        # Expires and Max-Age
        expiresCookiePolicy = policies[6]
        maxAgeCookiePolicy = policies[7]
        hasExpiresCookiePolicy = any(
            expiresCookiePolicy in cookie or maxAgeCookiePolicy in cookie for cookie in parsedCookies)

        if not hasExpiresCookiePolicy:
            vulnerabilities.append({**issueData[4], "POC": cookies})
        else:
            for cookie in parsedCookies:
                if expiresCookiePolicy in cookie:
                    try:
                        expires_str = cookie.split(
                            expiresCookiePolicy + "=")[-1].strip()
                        expires_date = datetime.strptime(
                            expires_str, "%a, %d-%b-%Y %H:%M:%S GMT")
                        if expires_date < datetime.utcnow():
                            vulnerabilities.append(
                                {**issueData[4], "POC": cookies})
                            break
                    except ValueError:
                        continue

        # Domain
        domainPolicy = policies[8]
        if not any(domainPolicy in cookie for cookie in parsedCookies):
            vulnerabilities.append({**issueData[5], "POC": cookies})

        # Path
        pathPolicy = policies[9]
        if not any(pathPolicy in cookie for cookie in parsedCookies):
            vulnerabilities.append({**issueData[6], "POC": cookies})

        logger.info("SC scan ended...")

    except Exception as e:
        logger.error(f"Error during SC analysis: {e}")


# ===========================
# SSL/TLS Analysis Function
# ===========================
def analyzeSSLTLS(headers: Headers, url: str, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze SSL/TLS configuration for weak protocols and ciphers using a secure socket connection.

    :param headers: Dictionary of HTTP headers.
    :param url: Target URL to extract hostname.
    :param checklist: Security policy definitions and issue metadata.
    :param vulnerabilities: Collection list to append discovered issues.
    """

    parsedUrl = urlparse(url)
    hostname = parsedUrl.hostname
    port = 443

    logger.info("SSL/TLS scan started...")

    try:
        sslTlsData = checklist[16]["SSL/TLS Check"]
        issueData = sslTlsData[0]["Data"]

        context = ssl.create_default_context()
        with socket.create_connection((hostname, port), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                # Cipher suite check
                cipher = ssock.cipher()[0]
                if any(weak in cipher.upper() for weak in WEAK_CIPHERS):
                    vulnerabilities.append(
                        {**issueData[0], "POC": f"{hostname}:{port} uses {cipher}"})

                # Certificate check
                cert = ssock.getpeercert()
                if cert:
                    notAfter = cert.get('notAfter')
                    if notAfter:
                        expire_time = datetime.strptime(
                            notAfter, '%b %d %H:%M:%S %Y %Z'
                            # Make expire_time timezone-aware
                        ).replace(tzinfo=UTC)
                        if expire_time < datetime.now(UTC):
                            vulnerabilities.append(
                                {**issueData[0], "POC": f"{hostname}:{port} expired on {notAfter}"})

                # SSL/TLS protocol check
                protocol = ssock.version()
                if protocol in INSECURE_PROTOCOLS:
                    vulnerabilities.append(
                        {**issueData[2], "POC": f"{hostname}:{port} uses {protocol}"})
    except (ssl.SSLError, CertificateError, socket.error, Exception) as e:
        logger.error("SSL/TLS scan failed: ", {e})
        vulnerabilities.append({
            "Vulnerability": "SSL/TLS Analysis",
            "Severity": "Info",
            "Description": "SSL/TLS connection could not be established or analyzed.",
            "Recommendation": "Ensure the server is reachable over HTTPS and has a valid certificate.",
            "POC": str(e)
        })

    logger.info("SSL/TLS scan ended...")


# ===========================
# Main Analysis Function
# ===========================
def analyzeUrl(headers: Headers, url: str, outputFormat: str = "json") -> List[Vulnerability]:
    """
    Perform a complete analysis of the HTTP headers.
    """
    vulnerabilities = []
    checklist = loadVulnerabilityData()

    if not checklist:
        logger.warning("No checklist data available. Skipping analysis.")
        return vulnerabilities

    # List of analysis functions
    analysisFunctions = [
        analyzeCsp,
        analyzeXContentTypeOptions,
        analyzeXFrameOptions,
        analyzeStrictTransportSecurity,
        analyzeXXSSProtection,
        analyzeReferrerPolicy,
        analyzePermissionsPolicy,
        analyzeCORS,
        analyzeCORP,
        analyzeCOOP,
        analyzeCoep,
        analyzeServerHeader,
        analyzeXPoweredBy,
        analyzeXAspNetVersion,
        analyzeXDnsPrefetchControl,
        analyzeCookies,
        analyzeSSLTLS
    ]

    if outputFormat != "json":
        for func in tqdm(analysisFunctions, desc="🔍 Analyzing Headers", unit="header", colour="yellow"):
            func(headers, url, checklist, vulnerabilities)
            time.sleep(1)
    else:
        for func in analysisFunctions:
            func(headers, url, checklist, vulnerabilities)

    return vulnerabilities


# ===========================
# Main Script Logic
# ===========================
def main() -> None:
    """
    Main function to execute the script.
    """
    parser = argparse.ArgumentParser(
        description="Analyze HTTP headers for security vulnerabilities.")
    parser.add_argument("--url", type=str, help="The URL to analyze.")
    parser.add_argument(
        "--output", type=str, choices=["text", "json"], default="json", help="Output format")
    args = parser.parse_args()

    headers = fetchHeaders(args.url)
    if headers:
        logger.info("Headers fetched successfully.")
    else:
        logger.error("Failed to fetch headers.")
        return

    logger.info(f"Starting analysis for URL: {args.url}")
    vulnerabilities = analyzeUrl(headers, args.url, args.output)

    if vulnerabilities:
        logger.info("Vulnerabilities detected.")
        if args.output == "json":
            print(json.dumps(vulnerabilities, indent=2))
        else:
            print(Fore.GREEN + json.dumps(vulnerabilities,
                                          indent=2) + Style.RESET_ALL)
    else:
        logger.info("No vulnerabilities detected.")
        if args.output != "json":
            print(Fore.GREEN + "✅ No vulnerabilities detected!" + Style.RESET_ALL)


# ===========================
# Entry point for the script
# ===========================
if __name__ == "__main__":
    main()
