import argparse
import json
import logging
import re
import time
from pathlib import Path
from typing import Dict, List, Union
import requests
from urllib.parse import urlparse
from tqdm import tqdm
from colorama import Fore, Style


# ===========================
# Logger Configuration
# ===========================
LOG_FILE = Path(__file__).parent / "Analysis.log"
logging.basicConfig(filename=LOG_FILE, level=logging.INFO,
                    format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("HeaderAnalyzer")


# ===========================
# Constants
# ===========================
VULNERABILITIES_FILE = Path(__file__).parent / "vulnerabilityList.json"


# ===========================
# Type Definitions
# ===========================
Headers = Dict[str, str]
Vulnerability = Dict[str, Union[str, Dict]]


# ===========================
# Helper Functions
# ===========================
def loadVulnerabilityData() -> List[Dict]:
    """
    Load vulnerability checklist data from a JSON file.
    :return: A list of vulnerabilities to check for.
    """
    try:
        with open(VULNERABILITIES_FILE, "r", encoding="utf-8") as file:
            data = json.load(file)
            return data.get("Missing HTTP Headers", [])
    except FileNotFoundError:
        logger.error(f"Vulnerability checklist file not found: {
                     VULNERABILITIES_FILE}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON file: {e}")
        return []


# ===========================
# URL Validation
# ===========================
def isValidUrl(url: str) -> bool:
    parsed_url = urlparse(url)
    return bool(parsed_url.scheme and parsed_url.netloc)


# ===========================
# Fetch Headers
# ===========================
def fetchHeaders(url: str) -> Headers:
    if not isValidUrl(url):
        logger.error(f"Invalid URL: {url}")
        return {}

    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return dict(response.headers)
    except requests.RequestException as e:
        logger.error(f"Request failed: {e}")
        return {}


# ===========================
# Header Analysis Functions
# ===========================
def analyzeCsp(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Content-Security-Policy header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        cspData = checklist[0]["Content-Security-Policy"]
        policies = cspData[0]["Policies"]
        issueData = cspData[0]["Data"]

        cspHeader = headers.get("content-security-policy")

        logger.info("CSP scan started...")
        if not cspHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        elif not all(policy in cspHeader for policy in policies):
            vulnerabilities.append(
                {**issueData[1], "POC": {"content-security-policy": cspHeader}})
        logger.info("CSP scan completed.")
    except Exception as e:
        logger.error(f"Error during CSP analysis: {e}")


def analyzeXContentTypeOptions(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Content-Type-Options header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xctoData = checklist[1]["X-Content-Type-Options"]
        policies = xctoData[0]["Policies"]
        issueData = xctoData[0]["Data"]

        xctoHeader = headers.get("x-content-type-options")

        logger.info("XCTO scan started...")
        if not xctoHeader or policies[0] not in xctoHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XCTO scan completed.")
    except Exception as e:
        logger.error(f"Error during XCTO analysis: {e}")


def analyzeXFrameOptions(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Frame-Options header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xfoData = checklist[2]["X-Frame-Options"]
        policies = xfoData[0]["Policies"]
        issueData = xfoData[0]["Data"]

        xfoHeader = headers.get("x-frame-options")

        logger.info("XFO scan started...")
        if not xfoHeader or not any(policy in xfoHeader for policy in policies):
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XFO scan completed.")
    except Exception as e:
        logger.error(f"Error during XFO analysis: {e}")


def analyzeStrictTransportSecurity(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Strict-Transport-Security header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        hstsData = checklist[3]["HTTP Strict-Transport-Security"]
        policies = hstsData[0]["Policies"]
        issueData = hstsData[0]["Data"]

        hstsHeader = headers.get("strict-transport-security")

        logger.info("HSTS scan started...")
        if not hstsHeader or not all(policy in hstsHeader for policy in policies):
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("HSTS scan completed.")
    except Exception as e:
        logger.error(f"Error during HSTS analysis: {e}")


def analyzeXXSSProtection(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-XSS-Protection header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xxssData = checklist[4]["X-XSS-Protection"]
        policies = xxssData[0]["Policies"]
        issueData = xxssData[0]["Data"]

        xxssHeader = headers.get("x-xss-protection")

        logger.info("XXSS scan started...")
        if not xxssHeader or policies[0] not in xxssHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XXSS scan completed.")
    except Exception as e:
        logger.error(f"Error during XXSS analysis: {e}")


def analyzeReferrerPolicy(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Referrer-Policy header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        refpData = checklist[5]["Referrer-Policy"]
        policies = refpData[0]["Policies"]
        issueData = refpData[0]["Data"]

        refpHeader = headers.get("referrer-policy")

        logger.info("Referrer-Policy scan started...")

        if not refpHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        elif not any(policy in refpHeader for policy in policies):
            vulnerabilities.append(
                {**issueData[1], "POC": {"referrer-policy": refpHeader}})

        logger.info("Referrer-Policy scan completed.")
    except Exception as e:
        logger.error(f"Error during Referrer-Policy analysis: {e}")


def analyzePermissionsPolicy(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Permissions-Policy header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        pphData = checklist[6]["Permissions-Policy"]
        issueData = pphData[0]["Data"]

        pphHeader = headers.get("permissions-policy")

        logger.info("Permissions-Policy scan started...")

        if not pphHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})

        logger.info("Permissions-Policy scan completed.")
    except Exception as e:
        logger.error(f"Error during Permissions-Policy analysis: {e}")


def analyzeCORS(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Resource-Sharing (CORS) headers.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        corsData = checklist[7]["Access-Control-Allow-Origin"]
        policies = corsData[0]["Policies"]
        issueData = corsData[0]["Data"]

        corsHeader = headers.get("access-control-allow-origin")
        corsCredHeader = headers.get("access-control-allow-credentials")
        varyHeader = headers.get("vary")
        originHeader = headers.get("origin")

        logger.info("CORS scan started...")

        if not corsHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        if "*" in corsHeader:
            vulnerabilities.append(
                {**issueData[1], "POC": {"access-control-allow-origin": corsHeader}})
            if corsCredHeader:
                vulnerabilities.append({**issueData[2], "POC": headers})

        if "null" in corsHeader:
            vulnerabilities.append(
                {**issueData[3], "POC": {"access-control-allow-origin": corsHeader}})

        if originHeader != corsHeader and "*" not in corsHeader:
            vulnerabilities.append({**issueData[4], "POC": headers})

        if varyHeader and "origin" not in varyHeader:
            vulnerabilities.append(
                {**issueData[5], "POC": {"vary": varyHeader}})

        logger.info("CORS scan completed.")
    except Exception as e:
        logger.error(f"Error during CORS analysis: {e}")


def analyzeCORP(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Resource-Policy (CORP) header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        corpData = checklist[8]["Cross-Origin-Resource-Policy"]
        policies = corpData[0]["Policies"]
        issueData = corpData[0]["Data"]

        corpHeader = headers.get("cross-origin-resource-policy")
        coepHeader = headers.get("cross-origin-embedder-policy")

        logger.info("CORP scan started...")

        if not corpHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        if policies[0] in corpHeader:
            vulnerabilities.append(
                {**issueData[1], "POC": {"cross-origin-resource-policy": corpHeader}})

        if coepHeader and policies[3] in coepHeader and policies[0] not in corpHeader:
            vulnerabilities.append({**issueData[3], "POC": headers})

        logger.info("CORP scan completed.")
    except Exception as e:
        logger.error(f"Error during CORP analysis: {e}")


def analyzeCOOP(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Opener-Policy (COOP) header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        coopData = checklist[9]["Cross-Origin-Opener-Policy"]
        policies = coopData[0]["Policies"]
        issueData = coopData[0]["Data"]

        coopHeader = headers.get("cross-origin-opener-policy")
        coepHeader = headers.get("cross-origin-embedder-policy")

        logger.info("COOP scan started...")

        if not coopHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
            return

        if policies[0] in coopHeader:
            vulnerabilities.append(
                {**issueData[1], "POC": {"cross-origin-opener-policy": coopHeader}})

        if policies[1] in coepHeader and not coepHeader:
            vulnerabilities.append({**issueData[2], "POC": headers})

        logger.info("COOP scan completed.")
    except Exception as e:
        logger.error(f"Error during COOP analysis: {e}")


def analyzeCoep(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cross-Origin-Embedder-Policy header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        coepData = checklist[10]["Cross-Origin-Embedder-Policy"]
        policies = coepData[0]["Policies"]
        issueData = coepData[0]["Data"]

        coepHeader = headers.get("cross-origin-embedder-policy")

        logger.info("COEP scan started...")
        if not coepHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        else:
            if any(policy in coepHeader for policy in policies):
                for i, policy in enumerate(policies):
                    if policy == policies[0]:  # Unsafe origin policy
                        vulnerabilities.append(
                            {**issueData[1], "POC": headers})
                    if policy == policies[1]:  # Required CORP policy missing
                        vulnerabilities.append(
                            {**issueData[2], "POC": headers})
        logger.info("COEP scan completed.")
    except Exception as e:
        logger.error(f"Error during COEP analysis: {e}")


def analyzeServerHeader(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Server header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        serverData = checklist[11]["Server"]
        issueData = serverData[0]["Data"]

        serverHeader = headers.get("server")

        logger.info("ServerHeader scan started...")
        if serverHeader:
            serverPattern = r"([a-zA-Z]+)\/([\d.]+)\s?\(([^)]+)\)?"
            matchesServerData = re.match(serverPattern, serverHeader)
            serverNameVersionPattern = r"([a-zA-Z]+)\/([\d.]+)"
            matchesServerNameVersion = re.match(
                serverNameVersionPattern, serverHeader)

            if matchesServerData:
                vulnerabilities.append({**issueData[0], "POC": headers})
            elif matchesServerNameVersion:
                vulnerabilities.append({**issueData[1], "POC": headers})
            else:
                vulnerabilities.append({**issueData[2], "POC": headers})
        logger.info("ServerHeader scan completed.")
    except Exception as e:
        logger.error(f"Error during Server Header analysis: {e}")


def analyzeXPoweredBy(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-Powered-By header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xpbData = checklist[12]["X-Powered-By"]
        issueData = xpbData[0]["Data"]

        xPoweredByHeader = headers.get("x-powered-by")

        logger.info("XPB scan started...")
        if xPoweredByHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XPB scan completed.")
    except Exception as e:
        logger.error(f"Error during XPB analysis: {e}")


def analyzeXAspNetVersion(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-AspNet-Version and X-AspNetMvc-Version headers.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xaspnetverData = checklist[13]["X-AspNet-Version"]
        issueData = xaspnetverData[0]["Data"]

        xAspnetVerHeader = headers.get("x-aspnet-version")
        xAspNetMvcVerHeader = headers.get("x-aspnetmvc-version")

        logger.info("XASPNETVER scan started...")
        if xAspnetVerHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        if xAspNetMvcVerHeader:
            vulnerabilities.append({**issueData[1], "POC": headers})
        logger.info("XASPNETVER scan completed.")
    except Exception as e:
        logger.error(f"Error during XASPNETVER analysis: {e}")


def analyzeXDnsPrefetchControl(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the X-DNS-Prefetch-Control header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        xdnspfData = checklist[14]["X-DNS-Prefetch-Control"]
        issueData = xdnspfData[0]["Data"]

        xdnspfHeader = headers.get("x-dns-prefetch-control")

        logger.info("XDNSPC scan started...")
        if xdnspfHeader:
            vulnerabilities.append({**issueData[0], "POC": headers})
        logger.info("XDNSPC scan completed.")
    except Exception as e:
        logger.error(f"Error during XDNSPC analysis: {e}")


def analyzeCookies(headers: Headers, checklist: List[Dict], vulnerabilities: List[Vulnerability]) -> None:
    """
    Analyze the Cookies header.

    :param headers: The HTTP headers to analyze.
    :param checklist: The loaded vulnerability checklist.
    :param vulnerabilities: A list to store detected vulnerabilities.
    """
    try:
        scData = checklist[15]["Cookies"]
        policies = scData[0]["Policies"]
        issueData = scData[0]["Data"]

        cookies = headers.get("set-cookie")
        if cookies and isinstance(cookies, str):
            cookies = cookies.split("; ")

        logger.info("SC scan started...")

        if cookies:
            for policy in policies:
                for cookie in cookies:
                    if policy in cookie:
                        vulnerabilities.append(
                            {**issueData[0], "POC": headers})
        logger.info("SC scan completed.")
    except Exception as e:
        logger.error(f"Error during SC analysis: {e}")


# ===========================
# Main Analysis Function
# ===========================
def analyzeHeaders(headers: Headers, url: str, outputFormat: str = "text") -> List[Vulnerability]:
    """
    Perform a complete analysis of the HTTP headers.
    """
    vulnerabilities = []
    checklist = loadVulnerabilityData()

    if not checklist:
        logger.warning("No checklist data available. Skipping analysis.")
        return vulnerabilities

    # List of analysis functions
    analysisFunctions = [
        analyzeCsp,
        analyzeXContentTypeOptions,
        analyzeXFrameOptions,
        analyzeStrictTransportSecurity,
        analyzeXXSSProtection,
        analyzeReferrerPolicy,
        analyzePermissionsPolicy,
        analyzeCORS,
        analyzeCORP,
        analyzeCOOP,
        analyzeCoep,
        analyzeServerHeader,
        analyzeXPoweredBy,
        analyzeXAspNetVersion,
        analyzeXDnsPrefetchControl,
        analyzeCookies
    ]

    if outputFormat != "json":
        for func in tqdm(analysisFunctions, desc="🔍 Analyzing Headers", unit="header", colour="yellow"):
            func(headers, checklist, vulnerabilities)
            time.sleep(1)
    else:
        for func in analysisFunctions:
            func(headers, checklist, vulnerabilities)

    return vulnerabilities


# ===========================
# Main Script Logic
# ===========================
def main() -> None:
    """
    Main function to execute the script.
    """
    parser = argparse.ArgumentParser(
        description="Analyze HTTP headers for security vulnerabilities.")
    parser.add_argument("--url", type=str, help="The URL to analyze.")
    parser.add_argument(
        "--output", type=str, choices=["text", "json"], default="text", help="Output format")
    args = parser.parse_args()

    headers = fetchHeaders(args.url)
    if headers:
        logger.info("Headers fetched successfully.")
    else:
        logger.error("Failed to fetch headers.")
        return

    logger.info(f"Starting analysis for URL: {args.url}")
    vulnerabilities = analyzeHeaders(headers, args.url, args.output)

    if vulnerabilities:
        logger.info("Vulnerabilities detected.")
        if args.output == "json":
            print(json.dumps(vulnerabilities, indent=2))
        else:
            print(Fore.GREEN + json.dumps(vulnerabilities,
                  indent=2) + Style.RESET_ALL)
    else:
        logger.info("No vulnerabilities detected.")
        if args.output != "json":
            print(Fore.GREEN + "✅ No vulnerabilities detected!" + Style.RESET_ALL)


# ===========================
# Entry point for the script
# ===========================
if __name__ == "__main__":
    main()
