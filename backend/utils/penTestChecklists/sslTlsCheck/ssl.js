const sslChecker = require("ssl-checker");
const tls = require("tls");
const fs = require("fs");
const path = require("path");

const logger = require("../../../configuration/logger");
const sslTlsCheckFile = path.join(__dirname, "sslTlsCheck.json");

const checkUrlScheme = (url) => {
  try {
    const parsedUrl = new URL(url);
    if (parsedUrl.protocol === "https:") {
      return parsedUrl.hostname;
    }
    return false;
  } catch (error) {
    logger.error(`Invalid URL format: ${url}`, error);
    return false;
  }
};

const loadVulnerabilities = () => {
  try {
    const data = fs.readFileSync(sslTlsCheckFile, "utf8");
    const vulData = JSON.parse(data)["SSL/TLS Check"];
    return vulData;
  } catch (err) {
    logger.error("Failed to load vulnerabilities data:", err);
    return [];
  }
};

const WEAK_CIPHER_SUITES = [
  "DES",
  "RC4",
  "3DES",
  "NULL",
  "SEED",
  "IDEA",
  "CAMELLIA",
];
const INSECURE_PROTOCOLS = ["SSLv2", "SSLv3", "TLSv1.0", "TLSv1.1"];

// Check for weak cipher suites
const checkWeakCipherSuites = (cipherSuites) => {
  return cipherSuites.some((cipher) =>
    WEAK_CIPHER_SUITES.some((weak) => cipher.includes(weak))
  );
};

// Check for insecure SSL/TLS protocol versions
const checkInsecureProtocols = (protocols) => {
  return INSECURE_PROTOCOLS.some((protocol) => protocols.includes(protocol));
};

// Manual TLS Check using `tls.connect`
const checkTLS = (hostname, port = 443) => {
  return new Promise((resolve, reject) => {
    const options = {
      host: hostname,
      port: port,
      servername: hostname,
      rejectUnauthorized: false,
    };

    const socket = tls.connect(options, () => {
      if (socket.authorized || !socket.authorizationError) {
        logger.info(`TLS connection authorized for ${hostname}`);
        resolve({ valid: true });
      } else {
        logger.error(
          `TLS connection unauthorized for ${hostname}: ${socket.authorizationError}`
        );
        resolve({ valid: false, error: socket.authorizationError });
      }
      socket.end();
    });

    socket.on("error", (error) => {
      logger.error(`TLS error for ${hostname}: ${error.message}`);
      reject(new Error(`TLS error: ${error.message}`));
    });
  });
};

const SSLTLSCheck = async (url) => {
  const vulnerabilitiesData = loadVulnerabilities();
  const sslTlsVulnerabilities = [];
  const hostname = checkUrlScheme(url);

  if (!hostname) {
    logger.warn(
      `Invalid URL scheme for SSL/TLS check: ${url}. Only HTTPS allowed.`
    );
    sslTlsVulnerabilities.push({
      Error: "Invalid URL scheme. Only HTTPS URLs are allowed.",
      Code: 400,
    });
    return sslTlsVulnerabilities;
  }

  // Check SSL Information
  let sslInfo = null;
  let tlsInfo = null;

  try {
    logger.info(`Starting SSL check for ${hostname}`);
    sslInfo = await sslChecker(hostname);
    logger.info(`SSL Info for ${hostname}: ${JSON.stringify(sslInfo)}`);
  } catch (error) {
    logger.error(
      `Error checking SSL for ${hostname}: ${error.message || error}`
    );
    sslTlsVulnerabilities.push({
      Error: `SSL Check Error: ${error.message || error}`,
      Code: 500,
    });
  }

  try {
    // Check TLS Information
    tlsInfo = await checkTLS(hostname);
  } catch (error) {
    logger.error(
      `Error during manual TLS check for ${hostname}: ${error.message || error}`
    );
    sslTlsVulnerabilities.push({
      Error: `TLS Check Error: ${error.message || error}`,
      Code: 500,
    });
  }

  // If both SSL and TLS info is null, return the error early
  if (!sslInfo && !tlsInfo) return sslTlsVulnerabilities;

  try {
    // Combine cipher suites and protocols from both checks
    const combinedCipherSuites = [
      ...(sslInfo?.cipherSuites || []),
      ...(tlsInfo?.cipherSuites || []),
    ];

    const combinedProtocols = [
      ...(sslInfo?.protocols || []),
      ...(tlsInfo?.protocols || []),
    ];

    // Log cipher suites and protocols for debugging
    logger.info(
      `Combined Cipher Suites: ${JSON.stringify(combinedCipherSuites)}`
    );
    logger.info(`Combined Protocols: ${JSON.stringify(combinedProtocols)}`);

    // Check for weak cipher suites
    if (checkWeakCipherSuites(combinedCipherSuites)) {
      const weakCipherSuites = vulnerabilitiesData[0];
      sslTlsVulnerabilities.push(weakCipherSuites);
    }

    // Check for valid SSL/TLS configuration
    if (!sslInfo?.valid || !tlsInfo?.valid) {
      const sslTlsValid = vulnerabilitiesData[1];
      sslTlsVulnerabilities.push(sslTlsValid);
    }

    // Check for insecure SSL/TLS protocol versions
    if (checkInsecureProtocols(combinedProtocols)) {
      const checkProtocol = vulnerabilitiesData[2];
      sslTlsVulnerabilities.push(checkProtocol);
    }

    // If vulnerabilities found, log them
    if (sslTlsVulnerabilities.length > 0) {
      logger.info(
        `SSL/TLS issues for ${hostname}: ${JSON.stringify(
          sslTlsVulnerabilities
        )}`
      );
    }
  } catch (error) {
    logger.error(`Processing error for ${hostname}: ${error.message || error}`);
    sslTlsVulnerabilities.push({
      Error: `Processing Error: ${error.message || error}`,
      Code: 500,
    });
  }

  return sslTlsVulnerabilities.length > 0
    ? sslTlsVulnerabilities
    : [{ Message: "No SSL/TLS issues found", Code: 200 }];
};

module.exports = {
  SSLTLSCheck,
};
