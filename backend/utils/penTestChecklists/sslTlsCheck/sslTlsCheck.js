const sslChecker = require("ssl-checker");
const tls = require("tls");
const fs = require("fs");
const path = require("path");

const logger = require("../../../configuration/logger");

const sslTlsCheckFile = path.join(__dirname, "sslTlsCheck.json");

const checkUrlScheme = (url) => {
  try {
    const parsedUrl = new URL(url);
    if (parsedUrl.protocol === "https:") {
      return parsedUrl.hostname;
    }
    return false;
  } catch (error) {
    logger.error(`Invalid URL format: ${url}`, error);
    return false;
  }
};

const loadVulnerabilities = () => {
  try {
    const data = fs.readFileSync(sslTlsCheckFile, "utf8");
    const vulData = JSON.parse(data)["SSL/TLS Check"];
    return vulData;
  } catch (err) {
    logger.error("Failed to load vulnerabilities data:", err);
    return [];
  }
};

const WEAK_CIPHER_SUITES = [
  "DES",
  "RC4",
  "3DES",
  "NULL",
  "SEED",
  "IDEA",
  "CAMELLIA",
];

const INSECURE_PROTOCOLS = ["SSLv2", "SSLv3", "TLSv1.0", "TLSv1.1"];

// Check for weak cipher suites
const checkWeakCipherSuites = (cipherSuites) => {
  return cipherSuites?.some((cipher) =>
    WEAK_CIPHER_SUITES.some((weak) => cipher.toUpperCase().includes(weak))
  );
};

// Check for insecure SSL/TLS protocol versions
const checkInsecureProtocols = (protocols) => {
  return protocols?.some((protocol) =>
    INSECURE_PROTOCOLS.includes(protocol.toUpperCase())
  );
};

// Manual TLS Check using `tls.connect`
const checkTLS = (hostname, port = 443) => {
  return new Promise((resolve, reject) => {
    const options = {
      host: hostname,
      port,
      servername: hostname,
      rejectUnauthorized: false,
    };

    const socket = tls.connect(options, () => {
      resolve({
        valid: socket.authorized || !socket.authorizationError,
        cipherSuites: socket.getCipher() ? [socket.getCipher().name] : [],
        protocols: [`TLSv${socket.getProtocol().replace("TLSv", "")}`],
      });
      socket.end();
    });

    socket.on("error", (error) => {
      logger.error(`TLS error for ${hostname}: ${error.message}`);
      reject(error);
    });
  });
};

const SSLTLSCheck = async (url) => {
  const vulnerabilitiesData = loadVulnerabilities();
  const sslTlsVulnerabilities = [];

  const hostname = checkUrlScheme(url);
  if (!hostname) {
    logger.warn(
      `Invalid URL scheme for SSL/TLS check: ${url}. Only HTTPS allowed.`
    );
    sslTlsVulnerabilities.push({
      Error: "Invalid URL scheme. Only HTTPS URLs are allowed.",
      Code: 400,
    });
    return sslTlsVulnerabilities;
  }

  // Check SSL Information
  let sslInfo = null;
  let tlsInfo = null;

  try {
    logger.info(`Starting SSL check for ${hostname}`);
    sslInfo = await sslChecker(hostname);
    logger.info(`SSL Info for ${hostname}: ${JSON.stringify(sslInfo)}`);
  } catch (error) {
    logger.error(
      `Error while checking SSL for ${hostname}: ${error.message || error}`
    );
    sslTlsVulnerabilities.push({
      Error: `Error while checking SSL for ${hostname}: ${
        error.message || error
      }`,
      Code: 500,
    });
  }

  try {
    // Check TLS Information
    tlsInfo = await checkTLS(hostname);
    logger.info(`TLS Info for ${hostname}: ${JSON.stringify(tlsInfo)}`);
  } catch (error) {
    if (error instanceof AggregateError) {
      error.errors.forEach((individualError) => {
        logger.error(
          `Individual TLS error for ${hostname}: ${
            individualError.message || individualError
          }`
        );
      });
    } else if (error.message.includes("tlsChecker is not defined")) {
      logger.error(
        `TLS Checker module is not defined. Please check the import: ${error.message}`
      );
    } else {
      logger.error(
        `Error while checking TLS for ${hostname}: ${error.message || error}`
      );
    }
  }

  // If both SSL and TLS info is null, return the error early
  if (!sslInfo && !tlsInfo) {
    return [{ Error: "SSL and TLS checks failed", Code: 500 }];
  }

  try {
    // Combine cipher suites and protocols from both checks
    const combinedCipherSuites = [
      ...(sslInfo?.cipherSuites || []),
      ...(tlsInfo?.cipherSuites || []),
    ];

    const combinedProtocols = [
      ...(sslInfo?.protocols || []),
      ...(tlsInfo?.protocols || []),
    ];

    // Log cipher suites and protocols for debugging
    logger.info(
      `Combined Cipher Suites: ${JSON.stringify(combinedCipherSuites)}`
    );
    logger.info(`Combined Protocols: ${JSON.stringify(combinedProtocols)}`);

    // Check for weak cipher suites
    if (checkWeakCipherSuites(combinedCipherSuites)) {
      const weakCipherSuites = vulnerabilitiesData[0];
      sslTlsVulnerabilities.push(weakCipherSuites);
    }

    // Check for valid SSL/TLS configuration
    if (!sslInfo?.valid || !tlsInfo?.valid) {
      const sslTlsValid = vulnerabilitiesData[1];
      sslTlsVulnerabilities.push(sslTlsValid);
    }

    // Check for insecure SSL/TLS protocol versions
    if (checkInsecureProtocols(combinedProtocols)) {
      const checkProtocol = vulnerabilitiesData[2];
      sslTlsVulnerabilities.push(checkProtocol);
    }
  } catch (error) {
    logger.error(
      `Error while processing SSL/TLS data for ${hostname}: ${
        error.message || error
      }`
    );
    sslTlsVulnerabilities.push({
      Error: `Error while processing SSL/TLS data for ${hostname}: ${
        error.message || error
      }`,
      Code: 500,
    });
  }

  if (
    sslTlsVulnerabilities &&
    sslTlsVulnerabilities.length > 0 &&
    !(
      sslTlsVulnerabilities.length === 1 &&
      sslTlsVulnerabilities[0].Message === "No SSL/TLS issues found"
    )
  ) {
    return sslTlsVulnerabilities;
  } else {
    return [{ Message: "No SSL/TLS issues found", Code: 200 }];
  }
};

module.exports = {
  SSLTLSCheck,
};
